package com.jayxu.playground.lang;

import java.util.Comparator;

import org.apache.commons.lang3.StringUtils;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.impl.factory.Lists;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

/**
 * This class contains object info generated by ClassIntrospector tool
 *
 * @author jay
 */
@RequiredArgsConstructor
public final class ObjectInfo {
    private static final String TOSTRING_FORMAT = "name: %s, type: %s, size: %d";
    /** Field name */
    @Getter
    private final String name;
    /** Field type name */
    @Getter
    private final Class<?> type;
    /** Field offset from the start of parent object */
    @Getter(AccessLevel.PROTECTED)
    private final long offset;
    /** Memory occupied by this field */
    @Getter
    private final long size;
    private final long arrayBaseOffset;
    /** Offset of the first cell in the array */
    private final int arrayLen;
    private final long arraySize;
    /** This object fields */
    private MutableList<ObjectInfo> children = Lists.mutable
        .<ObjectInfo> empty();
    private boolean snapshotDone;
    @Setter
    private int maxOutputLevel = -1;
    /**
     * Get the full amount of memory occupied by a given object. This value may
     * be slightly less than
     * an actual value because we don't worry about memory alignment - possible
     * padding after the last object field.
     * The result is equal to the last field offset + last field length + all
     * array sizes + all child objects deep sizes
     *
     * @return Deep object size
     */
    @Getter
    private long deepSize;
    @Getter
    private long shallowSize;

    static ObjectInfo nullObjectInfo(String name, long offset,
            Class<?> type) {
        return new ObjectInfo(name, type, offset, 0, 0, 0, 0);
    }

    void addChild(ObjectInfo info) {
        if (info != null) {
            this.children.add(info);
        }
    }

    private long calDeepSize() {
        return this.getShallowSize()
            + this.children.parallelStream().filter(c -> !c.type.isPrimitive())
                .mapToLong(ObjectInfo::getDeepSize).sum();
    }

    private long calShallowSize() {
        this.children = this.children
            .toSortedList(Comparator.comparing(ObjectInfo::getOffset));

        if (this.type == null || this.type.isPrimitive()) {
            return this.size;
        }

        var s = 0L;
        if (this.arrayBaseOffset != 0) {
            s += this.arrayBaseOffset + this.arraySize;
        } else if (this.children.isEmpty()) {
            s += this.offset;
        } else {
            s += this.children.getLast().size + this.children.getLast().offset;
        }

        return ObjectInfo.align(s);
    }

    /**
     * Calculate all sizes
     */
    synchronized void snapshot() {
        if (this.snapshotDone) {
            return;
        }

        this.shallowSize = this.calShallowSize();
        this.deepSize = this.calDeepSize();

        this.snapshotDone = true;
    }

    private static long align(long l) {
        return (l + 7) / 8 * 8;
    }

    @Override
    public String toString() {
        return ObjectInfo.TOSTRING_FORMAT.formatted(this.name,
            this.type, this.deepSize);
    }

    public String toDetails() {
        return "size: " + this.getDeepSize() + "\n"
            + this.toStringHelper(new StringBuilder(), 0).toString();
    }

    private StringBuilder toStringHelper(StringBuilder sb, int depth) {
        sb.append(StringUtils.repeat('\t', depth)).append("fieldName = ")
            .append(this.name).append(", type = ").append(this.type)
            .append(", offset = ").append(this.offset).append(", size = ")
            .append(this.size);

        if (this.arrayLen > 0) {
            sb.append(", arrayBaseOffset = ").append(this.arrayBaseOffset)
                .append(", arrayLen = ").append(this.arrayLen)
                .append(", arraySize = ").append(this.arraySize);
        }

        sb.append(", shallowSize = ").append(this.getShallowSize())
            .append(", deepSize = ").append(this.getDeepSize());

        if (this.maxOutputLevel < 0 || depth <= this.maxOutputLevel) {
            for (ObjectInfo child : this.children) {
                sb.append('\n');
                child.toStringHelper(sb, depth + 1);
            }
        }

        return sb;
    }
}
